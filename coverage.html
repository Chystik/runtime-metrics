
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>staticlint: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Chystik/runtime-metrics/cmd/staticlint/staticlint.go (85.7%)</option>
				
				<option value="file1">github.com/Chystik/runtime-metrics/internal/adapters/http_client/agent_client.go (74.4%)</option>
				
				<option value="file2">github.com/Chystik/runtime-metrics/internal/adapters/rest_api_handlers/db_handlers.go (100.0%)</option>
				
				<option value="file3">github.com/Chystik/runtime-metrics/internal/adapters/rest_api_handlers/metrics_handlers.go (92.6%)</option>
				
				<option value="file4">github.com/Chystik/runtime-metrics/internal/adapters/rest_api_handlers/router.go (100.0%)</option>
				
				<option value="file5">github.com/Chystik/runtime-metrics/internal/infrastructure/repository/inmemory/metrics_repository.go (100.0%)</option>
				
				<option value="file6">github.com/Chystik/runtime-metrics/internal/infrastructure/repository/postgres/metrics_repository.go (0.0%)</option>
				
				<option value="file7">github.com/Chystik/runtime-metrics/internal/infrastructure/storage/local/metrics_storage.go (0.0%)</option>
				
				<option value="file8">github.com/Chystik/runtime-metrics/internal/middleware/compressor.go (0.0%)</option>
				
				<option value="file9">github.com/Chystik/runtime-metrics/internal/middleware/compressor_pool.go (0.0%)</option>
				
				<option value="file10">github.com/Chystik/runtime-metrics/internal/middleware/hasher.go (0.0%)</option>
				
				<option value="file11">github.com/Chystik/runtime-metrics/internal/middleware/logger.go (0.0%)</option>
				
				<option value="file12">github.com/Chystik/runtime-metrics/internal/service/agent/metrics_service.go (98.0%)</option>
				
				<option value="file13">github.com/Chystik/runtime-metrics/internal/service/server/metrics_service.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "go/ast"

        "github.com/jingyugao/rowserrcheck/passes/rowserr"
        "github.com/timakin/bodyclose/passes/bodyclose"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"
)

// OsExitCheckAnalyzer checks for os.Exit call in main function of main package
var OsExitCheckAnalyzer = &amp;analysis.Analyzer{
        Name: "osexitcheck",
        Doc:  "check for os.Exit call in main function of main package",
        Run:  run,
}

var staticcheckAnalyzers = map[string]bool{
        // Various misuses of the standard library
        "SA1*": true,
        // Concurrency issues
        "SA2*": true,
        // Testing issues
        "SA3*": true,
        // Code that isn't really doing anything
        "SA4*": true,
        // Correctness issues
        "SA5*": true,
        // Performance issues
        "SA6*": true,
        //         Dubious code constructs that have a high probability of being wrong
        "SA9*": true,
}

var stylecheckAnalyzers = map[string]bool{
        // Incorrectly formatted error string
        "ST1005": true,
        // Poorly chosen receiver name
        "ST1006": true,
}

var customAnalyzers = []*analysis.Analyzer{
        // check for os.Exit call in main function of main package
        OsExitCheckAnalyzer,
}

var passesAnalyzers = []*analysis.Analyzer{
        // Checks consistency of Printf format strings and arguments
        printf.Analyzer,
        // Checks for shadowed variables
        shadow.Analyzer,
        // Checks struct field tags are well formed
        structtag.Analyzer,
}

var publicAnalyzers = []*analysis.Analyzer{
        // checks whether HTTP response body is closed successfully
        bodyclose.Analyzer,
        // checks whether Rows.Err is checked
        rowserr.NewAnalyzer(
                "github.com/jmoiron/sqlx",
        ),
}

type checks []*analysis.Analyzer

// adds staticcheck analyzers
func (c *checks) addStaticcheckAnalyzers() <span class="cov1" title="1">{
        for _, v := range staticcheck.Analyzers </span><span class="cov10" title="90">{
                // wildecard name check
                if staticcheckAnalyzers[fmt.Sprintf("%s*", v.Analyzer.Name[:3])] </span><span class="cov10" title="90">{
                        *c = append(*c, v.Analyzer)
                }</span>

                // specific name check
                <span class="cov10" title="90">if staticcheckAnalyzers[v.Analyzer.Name] </span><span class="cov0" title="0">{
                        *c = append(*c, v.Analyzer)
                }</span>
        }
}

// adds stylecheck analyzers
func (c *checks) addStylecheckAnalyzers() <span class="cov1" title="1">{
        for _, v := range stylecheck.Analyzers </span><span class="cov6" title="18">{
                // wildecard name check
                if stylecheckAnalyzers[fmt.Sprintf("%s*", v.Analyzer.Name[:3])] </span><span class="cov0" title="0">{
                        *c = append(*c, v.Analyzer)
                }</span>

                // specific name check
                <span class="cov6" title="18">if stylecheckAnalyzers[v.Analyzer.Name] </span><span class="cov2" title="2">{
                        *c = append(*c, v.Analyzer)
                }</span>
        }
}

// add passes analyzers
func (c *checks) addPassesAnalyzers() <span class="cov1" title="1">{
        *c = append(*c, passesAnalyzers...)
}</span>

// add custom analyzers
func (c *checks) addCustomAnalyzers() <span class="cov1" title="1">{
        *c = append(*c, customAnalyzers...)
}</span>

// add custom analyzers
func (c *checks) addPublicAnalyzers() <span class="cov1" title="1">{
        *c = append(*c, publicAnalyzers...)
}</span>

func run(pass *analysis.Pass) (any, error) <span class="cov2" title="2">{
        for _, f := range pass.Files </span><span class="cov2" title="2">{
                // обходим дерево разбора
                ast.Inspect(f, func(n ast.Node) bool </span><span class="cov9" title="88">{
                        // интересует только пакет main
                        if p, ok := n.(*ast.File); ok &amp;&amp; p.Name.Name == "main" </span><span class="cov2" title="2">{

                                // смотрим какие функции есть в пакете
                                for _, decl := range p.Decls </span><span class="cov4" title="5">{
                                        // интересует только функция main
                                        if mainFunc, ok := decl.(*ast.FuncDecl); ok &amp;&amp; mainFunc.Name.Name == "main" </span><span class="cov2" title="2">{

                                                // смотрим что там в ней внутри
                                                for _, b := range mainFunc.Body.List </span><span class="cov2" title="2">{
                                                        // интересуют только вызовы функций
                                                        if exp, ok := b.(*ast.ExprStmt); ok </span><span class="cov2" title="2">{
                                                                if caller, ok := exp.X.(*ast.CallExpr); ok </span><span class="cov2" title="2">{
                                                                        // ищем функию Exit
                                                                        if exitFunc, ok := caller.Fun.(*ast.SelectorExpr); ok </span><span class="cov1" title="1">{
                                                                                // именно из пакета os
                                                                                if pkg, ok := exitFunc.X.(*ast.Ident); ok &amp;&amp; pkg.Name == "os" </span><span class="cov1" title="1">{
                                                                                        if exitFunc.Sel.Name == "Exit" </span><span class="cov1" title="1">{
                                                                                                pass.Reportf(exitFunc.Sel.NamePos, "calling os.Exit in main function is not allowed")
                                                                                        }</span>
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                        <span class="cov9" title="88">return true</span>
                })
        }
        <span class="cov2" title="2">return nil, nil</span>
}

func addAnalyzers(c *checks) <span class="cov1" title="1">{
        c.addCustomAnalyzers()
        c.addStaticcheckAnalyzers()
        c.addStylecheckAnalyzers()
        c.addPassesAnalyzers()
        c.addPublicAnalyzers()
}</span>

func main() <span class="cov0" title="0">{
        var c checks
        addAnalyzers(&amp;c)

        multichecker.Main(
                c...,
        )
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Used to make API calls to the metrics server.
//
// Sends metrics to the metrics server with or without data compressing.
// Can send metrics in batch or one at a time.
package agentapiclient

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "github.com/Chystik/runtime-metrics/config"
        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"
)

var (
        errBadStatusCode = "resp status code: %s"
)

type agentAPIClient struct {
        client  service.HTTPClient
        address string
        shaKey  string
}

// New creates new agent API client, wich sends http requests to the metrics server
func New(c service.HTTPClient, s *config.AgentConfig) *agentAPIClient <span class="cov10" title="10">{
        return &amp;agentAPIClient{
                client:  c,
                address: s.Address,
                shaKey:  s.SHAkey,
        }
}</span>

// ReportMetrics sends metrics one by one to the metrics server
func (ac *agentAPIClient) ReportMetrics(ctx context.Context, metrics map[string]interface{}) error <span class="cov8" title="6">{
        for name, value := range metrics </span><span class="cov8" title="6">{
                var mType string

                switch t := value.(type) </span>{
                case float64:<span class="cov3" title="2">
                        mType = "gauge"</span>
                case int64:<span class="cov3" title="2">
                        mType = "counter"</span>
                default:<span class="cov3" title="2">
                        return fmt.Errorf("unknown metric type: %#v", t)</span>
                }

                <span class="cov6" title="4">url := fmt.Sprintf("http://%s/update/%s/%s/%v", ac.address, mType, name, value)

                request, err := http.NewRequestWithContext(ctx, http.MethodPost, url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="4">request.Header.Set("Content-Type", "text/plain")
                response, err := ac.client.Do(request)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="4">response.Body.Close()</span>
        }
        <span class="cov6" title="4">return nil</span>
}

// ReportMetricsJSON sends all metrics one by one to the metrics server using the JSON data format.
// It also compresses all data sent.
func (ac *agentAPIClient) ReportMetricsJSON(ctx context.Context, metrics map[string]models.Metric) error <span class="cov6" title="4">{
        for _, metric := range metrics </span><span class="cov7" title="5">{
                var buf, reqBody bytes.Buffer

                url := fmt.Sprintf("http://%s/update/", ac.address)
                err := json.NewEncoder(&amp;buf).Encode(metric)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="5">gz := gzip.NewWriter(&amp;reqBody)
                _, err = gz.Write(buf.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="5">err = gz.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="5">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, &amp;reqBody)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="5">req.Header.Set("Content-Type", "application/json")
                req.Header.Set("Accept-Encoding", "gzip")
                req.Header.Set("Content-Encoding", "gzip")
                resp, err := ac.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="5">defer resp.Body.Close()

                reader, err := gzip.NewReader(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="5">var p bytes.Buffer
                _, err = io.Copy(&amp;p, reader)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="5">defer reader.Close()

                // does something with decompressed response
                _ = p.String</span>
        }
        <span class="cov6" title="4">return nil</span>
}

// ReportMetricsJSONBatch sends all metrics in batch to the metrics server using JSON data format.
// It also compresses all data sent.
func (ac *agentAPIClient) ReportMetricsJSONBatch(ctx context.Context, metrics map[string]models.Metric) error <span class="cov3" title="2">{
        var ms []models.Metric
        var buf, reqBody bytes.Buffer

        for _, m := range metrics </span><span class="cov6" title="4">{
                ms = append(ms, m)
        }</span>

        <span class="cov3" title="2">url := fmt.Sprintf("http://%s/updates/", ac.address)
        err := json.NewEncoder(&amp;buf).Encode(ms)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">gz := gzip.NewWriter(&amp;reqBody)
        _, err = gz.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">err = gz.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, &amp;reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">if ac.shaKey != "" </span><span class="cov0" title="0">{
                h := hmac.New(sha256.New, []byte(ac.shaKey))
                _, err = h.Write(reqBody.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">sign := h.Sum(nil)
                hVal := base64.StdEncoding.EncodeToString(sign)
                req.Header.Set("HashSHA256", hVal)</span>
        }

        <span class="cov3" title="2">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept-Encoding", "gzip")
        req.Header.Set("Content-Encoding", "gzip")
        resp, err := ac.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf(errBadStatusCode, resp.Status)
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "net/http"
        "time"

        "github.com/Chystik/runtime-metrics/internal/service"
)

type dbHandlers struct {
        db          service.DBClient
        logger      service.AppLogger
        pingTimeout time.Duration
}

func NewDBHandlers(db service.DBClient, logger service.AppLogger, pingTimeout time.Duration) *dbHandlers <span class="cov10" title="4">{
        return &amp;dbHandlers{
                db:          db,
                logger:      logger,
                pingTimeout: pingTimeout,
        }
}</span>

func (dh *dbHandlers) PingDB(w http.ResponseWriter, r *http.Request) <span class="cov5" title="2">{
        ctx, cancel := context.WithTimeout(r.Context(), dh.pingTimeout)
        defer cancel()

        w.Header().Set("Content-Type", "text/plain")

        err := dh.db.Ping(ctx)
        if err != nil </span><span class="cov1" title="1">{
                dh.logger.Error(err.Error())
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "bytes"
        "encoding/json"
        "log"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "text/template"

        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"
)

const tplStr = `&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Type&lt;/th&gt;
            &lt;th&gt;Value&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{range . }}
            &lt;tr&gt;
                &lt;td&gt;{{ .Name }}&lt;/td&gt;
                &lt;td&gt;{{ .Type }}&lt;/td&gt;
                &lt;td&gt;{{ .Value }}&lt;/td&gt;
            &lt;/tr&gt;
        {{ end }}
    &lt;/tbody&gt;
&lt;/table&gt;`

type metricsHandlers struct {
        metricsService service.MetricsService
}

func NewMetricsHandlers(ms service.MetricsService) *metricsHandlers <span class="cov10" title="31">{
        h := &amp;metricsHandlers{metricsService: ms}
        return h
}</span>

func (mh *metricsHandlers) UpdateMetric(w http.ResponseWriter, r *http.Request) <span class="cov7" title="11">{
        var (
                pathRaw string
                path    []string
                metric  models.Metric
                err     error
        )

        if r.Method != http.MethodPost </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov7" title="10">pathRaw = strings.TrimLeft(r.URL.Path, "/update")
        path = strings.Split(pathRaw, "/")

        if len(path) != 3 </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>
        <span class="cov6" title="9">metric.ID = path[1]

        switch path[0] </span>{
        case "gauge":<span class="cov5" title="5">
                v := new(float64)

                *v, err = strconv.ParseFloat(path[2], 64)
                if err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov4" title="4">metric.Value = v
                err = mh.metricsService.UpdateGauge(r.Context(), metric)
                if err != nil </span><span class="cov2" title="2">{
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        case "counter":<span class="cov3" title="3">
                var val int
                var v = new(int64)

                val, err = strconv.Atoi(path[2])
                if err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>
                <span class="cov2" title="2">*v = int64(val)

                metric.Delta = v
                err = mh.metricsService.UpdateCounter(r.Context(), metric)
                if err != nil </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        default:<span class="cov1" title="1">
                w.WriteHeader(http.StatusBadRequest)
                return</span>
        }

        <span class="cov3" title="3">w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)</span>
}

func (mh *metricsHandlers) GetMetric(w http.ResponseWriter, r *http.Request) <span class="cov5" title="6">{
        var (
                pathRaw    string
                path       []string
                metricName string
                metricType string
                metric     models.Metric
                result     string
                err        error
        )

        if r.Method != http.MethodGet </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov5" title="5">pathRaw = strings.TrimLeft(r.URL.Path, "/value")
        path = strings.Split(pathRaw, "/")

        if len(path) != 2 </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov4" title="4">metricName = path[1]
        metricType = path[0]

        metric, err = mh.metricsService.Get(r.Context(), models.Metric{ID: metricName, MType: metricType})
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov3" title="3">switch metricType </span>{
        case "gauge":<span class="cov1" title="1">
                result = strconv.FormatFloat(*metric.Value, 'f', -1, 64)</span>
        case "counter":<span class="cov1" title="1">
                result = strconv.FormatInt(*metric.Delta, 10)</span>
        default:<span class="cov1" title="1">
                w.WriteHeader(http.StatusBadRequest)
                return</span>
        }

        <span class="cov2" title="2">w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)
        _, err = w.Write([]byte(result))
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (mh *metricsHandlers) UpdateMetricJSON(w http.ResponseWriter, r *http.Request) <span class="cov5" title="5">{
        var (
                metric models.Metric
                buf    bytes.Buffer
                err    error
        )

        err = json.NewDecoder(r.Body).Decode(&amp;metric)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="4">switch metric.MType </span>{
        case "gauge":<span class="cov2" title="2">
                err = mh.metricsService.UpdateGauge(r.Context(), metric)</span>
        case "counter":<span class="cov2" title="2">
                err = mh.metricsService.UpdateCounter(r.Context(), metric)</span>
        }
        <span class="cov4" title="4">if err != nil </span><span class="cov2" title="2">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov2" title="2">err = json.NewEncoder(&amp;buf).Encode(metric)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov2" title="2">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, err = w.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (mh *metricsHandlers) UpdateMetricsJSON(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        var (
                metrics []models.Metric
                err     error
        )

        err = json.NewDecoder(r.Body).Decode(&amp;metrics)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov2" title="2">err = mh.metricsService.UpdateList(r.Context(), metrics)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)</span>
}

func (mh *metricsHandlers) GetMetricJSON(w http.ResponseWriter, r *http.Request) <span class="cov3" title="3">{
        var (
                metric models.Metric
                buf    bytes.Buffer
                err    error
        )

        err = json.NewDecoder(r.Body).Decode(&amp;metric)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov2" title="2">m, err := mh.metricsService.Get(r.Context(), metric)
        if err != nil </span><span class="cov1" title="1">{
                w.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov1" title="1">err = json.NewEncoder(&amp;buf).Encode(m)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, err = w.Write(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

func (mh *metricsHandlers) AllMetrics(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        type formatMetrics struct {
                Name, Type, Value string
        }

        var fm []formatMetrics

        tpl, err := template.New("table").Parse(tplStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov1" title="1">m, err := mh.metricsService.GetAll(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov1" title="1">for i := range m </span><span class="cov7" title="10">{
                var v string

                if m[i].Value != nil </span><span class="cov6" title="8">{
                        v = strconv.FormatFloat(*m[i].Value, 'f', -1, 64)
                }</span>
                <span class="cov7" title="10">if m[i].Delta != nil </span><span class="cov2" title="2">{
                        v = strconv.FormatInt(*m[i].Delta, 10)
                }</span>

                <span class="cov7" title="10">fm = append(fm, formatMetrics{Name: m[i].ID, Type: m[i].MType, Value: v})</span>
        }

        <span class="cov1" title="1">sort.Slice(fm, func(i, j int) bool </span><span class="cov6" title="9">{
                return fm[i].Name &lt; fm[j].Name
        }</span>)

        <span class="cov1" title="1">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        err = tpl.Execute(w, fm)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "time"

        "github.com/Chystik/runtime-metrics/config"
        md "github.com/Chystik/runtime-metrics/internal/middleware"
        "github.com/Chystik/runtime-metrics/internal/service"

        "github.com/go-chi/chi/middleware"
        "github.com/go-chi/chi/v5"
)

func NewRouter(
        cfg *config.ServerConfig,
        router *chi.Mux,
        ms service.MetricsService,
        db service.DBClient,
        pingTimeout time.Duration,
        logger service.AppLogger,
) <span class="cov8" title="1">{
        // middleware
        router.Use(md.MidLogger(logger).WithLogging)
        router.Use(md.NewHasher(cfg.SHAkey, "HashSHA256").WithHasher)
        router.Use(md.GzipPoolMiddleware())
        router.Use(middleware.Recoverer)

        // routes
        mh := NewMetricsHandlers(ms)

        router.Route("/update/", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Post("/", mh.UpdateMetricJSON)
                r.Post("/*", mh.UpdateMetric)
        }</span>)
        <span class="cov8" title="1">router.Route("/value/", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Post("/", mh.GetMetricJSON)
                r.Post("/*", mh.GetMetric)
        }</span>)
        <span class="cov8" title="1">router.Get("/value/*", mh.GetMetric)
        if db != nil </span><span class="cov8" title="1">{
                dh := NewDBHandlers(db, logger, pingTimeout)
                router.Get("/ping", dh.PingDB)
        }</span>
        <span class="cov8" title="1">router.Get("/", mh.AllMetrics)
        router.Post("/updates/", mh.UpdateMetricsJSON)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package inmemory

import (
        "context"
        "errors"
        "fmt"
        "sync"

        "github.com/Chystik/runtime-metrics/config"
        "github.com/Chystik/runtime-metrics/internal/models"
)

var (
        ErrNotFoundMetric = errors.New("not found in repository")
)

type memStorage struct {
        data map[string]models.Metric
        Mu   sync.RWMutex
}

func NewMetricsRepo(cfg *config.ServerConfig) *memStorage <span class="cov1" title="1">{
        return &amp;memStorage{data: make(map[string]models.Metric)}
}</span>

func (ms *memStorage) UpdateGauge(ctx context.Context, metric models.Metric) error <span class="cov10" title="2">{
        ms.Mu.Lock()
        defer ms.Mu.Unlock()

        m, ok := ms.data[metric.ID]
        if !ok </span><span class="cov1" title="1">{
                ms.data[metric.ID] = metric
        }</span> else<span class="cov1" title="1"> {
                m.Value = metric.Value
                ms.data[metric.ID] = m
        }</span>

        <span class="cov10" title="2">return nil</span>
}

func (ms *memStorage) UpdateCounter(ctx context.Context, metric models.Metric) error <span class="cov10" title="2">{
        ms.Mu.Lock()
        defer ms.Mu.Unlock()

        m, ok := ms.data[metric.ID]
        if !ok </span><span class="cov1" title="1">{
                ms.data[metric.ID] = metric
        }</span> else<span class="cov1" title="1"> {
                *m.Delta = *metric.Delta + *m.Delta
                ms.data[metric.ID] = m
        }</span>

        <span class="cov10" title="2">return nil</span>
}

func (ms *memStorage) Get(ctx context.Context, metric models.Metric) (models.Metric, error) <span class="cov10" title="2">{
        ms.Mu.RLock()
        defer ms.Mu.RUnlock()

        m, ok := ms.data[metric.ID]
        if !ok </span><span class="cov1" title="1">{
                return models.Metric{ID: metric.ID, MType: "", Delta: nil, Value: nil}, fmt.Errorf("metric with ID %s %w", metric.ID, ErrNotFoundMetric)
        }</span>

        <span class="cov1" title="1">return m, nil</span>
}

func (ms *memStorage) GetAll(ctx context.Context) ([]models.Metric, error) <span class="cov1" title="1">{
        var metrics []models.Metric

        for _, v := range ms.data </span><span class="cov10" title="2">{
                ms.Mu.RLock()
                m := v
                ms.Mu.RUnlock()
                metrics = append(metrics, m)
        }</span>

        <span class="cov1" title="1">return metrics, nil</span>
}

func (ms *memStorage) UpdateList(ctx context.Context, metrics []models.Metric) error <span class="cov1" title="1">{
        for _, m := range metrics </span><span class="cov10" title="2">{
                ms.Mu.Lock()
                ms.data[m.ID] = m
                ms.Mu.Unlock()
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package postgresrepo

import (
        "context"
        "database/sql"
        "errors"
        "sort"

        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"

        "github.com/jmoiron/sqlx"
)

var (
        ErrNotFoundMetric = errors.New("not found in repository")
)

type pgRepo struct {
        db *sqlx.DB
        r  service.ConnectionRetrier
        l  service.AppLogger
}

func NewMetricsRepo(db *sqlx.DB, r service.ConnectionRetrier, logger service.AppLogger) *pgRepo <span class="cov0" title="0">{
        return &amp;pgRepo{
                db: db,
                r:  r,
                l:  logger,
        }
}</span>

func (pg *pgRepo) UpdateGauge(ctx context.Context, metric models.Metric) error <span class="cov0" title="0">{
        query := `
                        INSERT INTO        praktikum.metrics (id, m_type, m_value)
                        VALUES ($1, $2, $3)
                        ON CONFLICT (id) DO 
                        UPDATE SET 
                                m_value = EXCLUDED.m_value`

        err := pg.r.DoWithRetry(func() error </span><span class="cov0" title="0">{
                _, err := pg.db.ExecContext(ctx, query, metric.ID, metric.MType, metric.Value)
                return err
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pg *pgRepo) UpdateCounter(ctx context.Context, metric models.Metric) error <span class="cov0" title="0">{
        query := `
                        INSERT INTO        praktikum.metrics (id, m_type, m_delta)
                        VALUES ($1, $2, $3)
                        ON CONFLICT (id) DO 
                        UPDATE SET 
                                m_delta = $3 + (SELECT m_delta
                                        FROM praktikum.metrics
                                        WHERE id = $1)`

        err := pg.r.DoWithRetry(func() error </span><span class="cov0" title="0">{
                _, err := pg.db.ExecContext(ctx, query, metric.ID, metric.MType, metric.Delta)
                return err
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (pg *pgRepo) Get(ctx context.Context, metric models.Metric) (models.Metric, error) <span class="cov0" title="0">{
        var m models.Metric

        query := `
                        SELECT id, m_type, m_value, m_delta
                        FROM praktikum.metrics
                        WHERE id = $1`

        err := pg.r.DoWithRetry(func() error </span><span class="cov0" title="0">{
                return pg.db.GetContext(ctx, &amp;m, query, metric.ID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return m, ErrNotFoundMetric
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

func (pg *pgRepo) GetAll(ctx context.Context) ([]models.Metric, error) <span class="cov0" title="0">{
        var metrics []models.Metric
        var err error

        query := `
                        SELECT id, m_type, m_value, m_delta
                        FROM praktikum.metrics`

        err = pg.r.DoWithRetry(func() error </span><span class="cov0" title="0">{
                err = pg.db.SelectContext(ctx, &amp;metrics, query)
                return err
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return metrics, nil</span>
}

func (pg *pgRepo) UpdateList(ctx context.Context, metrics []models.Metric) (err error) <span class="cov0" title="0">{
        var tx *sql.Tx

        sort.Slice(metrics, func(i, j int) bool </span><span class="cov0" title="0">{ // prevent error on concurrent update: deadlock detected (SQLSTATE 40P01)
                return metrics[i].ID &lt; metrics[j].ID
        }</span>)

        <span class="cov0" title="0">err = pg.r.DoWithRetry(func() error </span><span class="cov0" title="0">{
                tx, err = pg.db.Begin()
                return err
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                e := tx.Rollback()
                if e.Error() != "sql: transaction has already been committed or rolled back" </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }()

        <span class="cov0" title="0">query := `
                        INSERT INTO        praktikum.metrics (id, m_type, m_value, m_delta)
                        VALUES ($1, $2, $3, $4)
                        ON CONFLICT (id) DO 
                        UPDATE SET 
                                m_value = EXCLUDED.m_value, 
                                m_delta = $4 + (SELECT m_delta
                                FROM praktikum.metrics
                                WHERE id = $1)`

        stmt, err := tx.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">for _, m := range metrics </span><span class="cov0" title="0">{
                _, err = stmt.ExecContext(ctx,
                        m.ID,
                        m.MType,
                        m.Value,
                        m.Delta,
                )
                if err != nil </span><span class="cov0" title="0">{
                        pg.l.Error(err.Error())
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                pg.l.Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package localfs

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/Chystik/runtime-metrics/config"
        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"
)

type localStorage struct {
        metricsRepo service.MetricsRepository
        file        *os.File
        encoder     *json.Encoder
        decoder     *json.Decoder
}

func NewMetricsStorage(cfg *config.ServerConfig, repo service.MetricsRepository) (*localStorage, error) <span class="cov0" title="0">{
        if cfg.FileStoragePath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file path not specified in server config: %v", cfg)
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(cfg.FileStoragePath, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encoder := json.NewEncoder(file)
        decoder := json.NewDecoder(file)

        return &amp;localStorage{
                metricsRepo: repo,
                file:        file,
                encoder:     encoder,
                decoder:     decoder,
        }, nil</span>
}

func (ls *localStorage) Read() error <span class="cov0" title="0">{
        var m []models.Metric

        err := ls.decoder.Decode(&amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ls.metricsRepo.UpdateList(context.Background(), m)</span>
}

func (ls *localStorage) Write() error <span class="cov0" title="0">{
        err := ls.file.Truncate(0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = ls.file.Seek(0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m, err := ls.metricsRepo.GetAll(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ls.encoder.Encode(m)</span>
}

func (ls *localStorage) CloseFile() error <span class="cov0" title="0">{
        if ls.file == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return ls.file.Close()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
)

// compressWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// сжимать передаваемые данные и выставлять правильные HTTP-заголовки
type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

func newCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov0" title="0">{
        return &amp;compressWriter{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

func (c *compressWriter) Header() http.Header <span class="cov0" title="0">{
        return c.w.Header()
}</span>

func (c *compressWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        // сжимаем данные только для контента с типами application/json и text/html
        ct := c.w.Header().Get("Content-Type")
        supportsCTypes := strings.Contains(ct, "application/json") || strings.Contains(ct, "text/html")

        if !supportsCTypes </span><span class="cov0" title="0">{
                return c.w.Write(p)
        }</span>

        <span class="cov0" title="0">return c.zw.Write(p)</span>
}

func (c *compressWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode &lt; 300 </span><span class="cov0" title="0">{
                c.w.Header().Set("Content-Encoding", "gzip")
        }</span>
        <span class="cov0" title="0">c.w.WriteHeader(statusCode)</span>
}

// Close закрывает gzip.Writer и досылает все данные из буфера.
func (c *compressWriter) Close() error <span class="cov0" title="0">{
        return c.zw.Close()
}</span>

// compressReader реализует интерфейс io.ReadCloser и позволяет прозрачно для сервера
// декомпрессировать получаемые от клиента данные
type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov0" title="0">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov0" title="0">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.zr.Close()</span>
}

func GzipMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        gzipFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // по умолчанию устанавливаем оригинальный http.ResponseWriter как тот,
                // который будем передавать следующей функции
                ow := w

                // проверяем, что клиент умеет получать от сервера сжатые данные в формате gzip
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")

                if supportsGzip </span><span class="cov0" title="0">{
                        // оборачиваем оригинальный http.ResponseWriter новым с поддержкой сжатия
                        cw := newCompressWriter(w)
                        // меняем оригинальный http.ResponseWriter на новый
                        ow = cw
                        // не забываем отправить клиенту все сжатые данные после завершения middleware
                        defer cw.Close()
                }</span>

                // проверяем, что клиент отправил серверу сжатые данные в формате gzip
                <span class="cov0" title="0">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")

                if sendsGzip </span><span class="cov0" title="0">{
                        // оборачиваем тело запроса в io.Reader с поддержкой декомпрессии
                        cr, err := newCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        // меняем тело запроса на новое
                        <span class="cov0" title="0">r.Body = cr
                        defer cr.Close()</span>
                }

                // передаём управление хендлеру
                <span class="cov0" title="0">next.ServeHTTP(ow, r)</span>

        }
        <span class="cov0" title="0">return http.HandlerFunc(gzipFn)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
        "sync"
)

// compressPWriter реализует интерфейс http.ResponseWriter и позволяет прозрачно для сервера
// сжимать передаваемые данные и выставлять правильные HTTP-заголовки
type compressPWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

type gzWriterPool struct {
        gz sync.Pool
}

func GzipPoolMiddleware() func(http.Handler) http.Handler <span class="cov0" title="0">{
        gzp := &amp;gzWriterPool{
                gz: sync.Pool{
                        New: func() any </span><span class="cov0" title="0">{
                                return gzip.NewWriter(io.Discard)
                        }</span>,
                },
        }
        <span class="cov0" title="0">return gzp.gzipPoolMiddleware</span>
}

func (p *gzWriterPool) newCompressPWriter(w http.ResponseWriter) *compressPWriter <span class="cov0" title="0">{
        gz, _ := p.gz.Get().(*gzip.Writer)
        gz.Reset(w)

        return &amp;compressPWriter{
                w:  w,
                zw: gz,
        }
}</span>

func (c *compressPWriter) Header() http.Header <span class="cov0" title="0">{
        return c.w.Header()
}</span>

func (c *compressPWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        // сжимаем данные только для контента с типами application/json и text/html
        ct := c.w.Header().Get("Content-Type")
        supportsCTypes := strings.Contains(ct, "application/json") || strings.Contains(ct, "text/html")

        if !supportsCTypes </span><span class="cov0" title="0">{
                return c.w.Write(p)
        }</span>

        <span class="cov0" title="0">return c.zw.Write(p)</span>
}

func (c *compressPWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode &lt; 300 </span><span class="cov0" title="0">{
                c.w.Header().Set("Content-Encoding", "gzip")
        }</span>
        <span class="cov0" title="0">c.w.WriteHeader(statusCode)</span>
}

// Close закрывает gzip.Writer и досылает все данные из буфера.
func (c *compressPWriter) Close() error <span class="cov0" title="0">{
        return c.zw.Close()
}</span>

func (p *gzWriterPool) gzipPoolMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        gzipFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // по умолчанию устанавливаем оригинальный http.ResponseWriter как тот,
                // который будем передавать следующей функции
                ow := w

                // проверяем, что клиент умеет получать от сервера сжатые данные в формате gzip
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")

                if supportsGzip </span><span class="cov0" title="0">{
                        // оборачиваем оригинальный http.ResponseWriter новым с поддержкой сжатия
                        cw := p.newCompressPWriter(w)
                        // меняем оригинальный http.ResponseWriter на новый
                        ow = cw
                        //defer cw.zw.Reset(io.Discard)
                        defer p.gz.Put(cw.zw)
                        // не забываем отправить клиенту все сжатые данные после завершения middleware
                        defer cw.Close()
                }</span>

                // проверяем, что клиент отправил серверу сжатые данные в формате gzip
                <span class="cov0" title="0">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")

                if sendsGzip </span><span class="cov0" title="0">{
                        // оборачиваем тело запроса в io.Reader с поддержкой декомпрессии
                        cr, err := newCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        // меняем тело запроса на новое
                        <span class="cov0" title="0">r.Body = cr
                        defer cr.Close()</span>
                }

                // передаём управление хендлеру
                <span class="cov0" title="0">next.ServeHTTP(ow, r)</span>

        }
        <span class="cov0" title="0">return http.HandlerFunc(gzipFn)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "io"
        "net/http"
)

type (
        hasherResponseWriter struct {
                http.ResponseWriter
                buf    bytes.Buffer
                status int
        }

        hasher struct {
                key        []byte
                headerName string
        }
)

func NewHasher(key string, headerName string) *hasher <span class="cov0" title="0">{
        return &amp;hasher{
                key:        []byte(key),
                headerName: headerName,
        }
}</span>

func (hw *hasherResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return hw.buf.Write(b)
}</span>

func (hw *hasherResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        hw.status = statusCode
}</span>

func (h *hasher) WithHasher(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // read req
                containHash := r.Header.Get(h.headerName)
                ow := &amp;hasherResponseWriter{
                        ResponseWriter: w,
                        status:         200,
                }

                if containHash != "" &amp;&amp; len(h.key) &gt; 0 </span><span class="cov0" title="0">{
                        // get hash from header
                        requestedHash, _ := base64.StdEncoding.DecodeString(r.Header.Get(h.headerName))

                        // calculate hash
                        hm := hmac.New(sha256.New, h.key)

                        // read body to calculate hash
                        body, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">defer r.Body.Close()

                        hm.Write(body)
                        calculatedHash := hm.Sum(nil)

                        if !hmac.Equal(requestedHash, calculatedHash) </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        // set new body, wich will contain same data we read
                        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewBuffer(body))</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(ow, r)

                // calculate hash
                if ow.status &lt; 300 &amp;&amp; len(h.key) &gt; 0 </span><span class="cov0" title="0">{
                        hs := hmac.New(sha256.New, h.key)
                        hs.Write(ow.buf.Bytes())
                        sign := hs.Sum(nil)
                        calculatedHash := base64.StdEncoding.EncodeToString(sign)
                        w.Header().Set(h.headerName, calculatedHash)
                }</span>

                <span class="cov0" title="0">w.WriteHeader(ow.status)
                _, err := w.Write(ow.buf.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/Chystik/runtime-metrics/internal/service"
        "go.uber.org/zap"
)

type (
        responseData struct {
                status int
                size   int
        }

        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *responseData
        }

        midLogger struct {
                service.AppLogger
        }
)

func MidLogger(l service.AppLogger) *midLogger <span class="cov0" title="0">{
        return &amp;midLogger{l}
}</span>

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := r.ResponseWriter.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">r.responseData.size += size
        return size, err</span>
}

func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode
}</span>

func (l *midLogger) WithLogging(next http.Handler) http.Handler <span class="cov0" title="0">{
        logFn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                responseData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w,
                        responseData:   responseData,
                }
                l.Info(
                        "request started",
                        zap.String("uri", r.RequestURI),
                        zap.String("method", r.Method),
                )

                next.ServeHTTP(&amp;lw, r)

                duration := time.Since(start)

                l.Info(
                        "response completed",
                        zap.Int("status", responseData.status),
                        zap.Duration("duration", duration),
                        zap.Int("size", responseData.size),
                )
        }</span>
        <span class="cov0" title="0">return http.HandlerFunc(logFn)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package agentservice

import (
        "context"
        "math/rand"
        "reflect"
        "runtime"
        "sync"

        "github.com/Chystik/runtime-metrics/config"
        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
)

type AgentService interface {
        UpdateMetrics()
        UpdateGoPsUtilMetrics()
        ReportMetrics(context.Context) error
}

type agentService struct {
        collectableMetrics config.CollectableMetrics
        runtimeMetrics     runtime.MemStats
        memMetrics         *mem.VirtualMemoryStat
        cpuMetrics         []cpu.InfoStat
        mu                 sync.RWMutex
        cache              map[string]models.Metric
        client             service.AgentAPIClient
}

func New(c service.AgentAPIClient, cm config.CollectableMetrics) *agentService <span class="cov7" title="3">{
        cache := make(map[string]models.Metric)

        cache["PollCount"] = models.Metric{ID: "PollCount", MType: "counter", Delta: new(int64)}
        cache["RandomValue"] = models.Metric{ID: "RandomValue", MType: "gauge", Value: new(float64)}
        cache["TotalMemory"] = models.Metric{ID: "TotalMemory", Value: new(float64)}
        cache["FreeMemory"] = models.Metric{ID: "FreeMemory", Value: new(float64)}
        cache["CPUutilization1"] = models.Metric{ID: "CPUutilization1", Value: new(float64)}
        for i := range cm </span><span class="cov10" title="5">{
                cache[cm[i]] = models.Metric{ID: cm[i], Value: new(float64)}
        }</span>

        <span class="cov7" title="3">return &amp;agentService{
                collectableMetrics: cm,
                runtimeMetrics:     runtime.MemStats{},
                memMetrics:         &amp;mem.VirtualMemoryStat{},
                cpuMetrics:         []cpu.InfoStat{},
                cache:              cache,
                client:             c,
        }</span>
}

func (as *agentService) UpdateMetrics() <span class="cov1" title="1">{
        as.mu.Lock()
        defer as.mu.Unlock()

        runtime.ReadMemStats(&amp;as.runtimeMetrics)

        for i := range as.collectableMetrics </span><span class="cov10" title="5">{
                r := reflect.ValueOf(as.runtimeMetrics)
                f := r.FieldByName(as.collectableMetrics[i])
                v := f.Interface()

                m, ok := as.cache[as.collectableMetrics[i]]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="5">switch val := v.(type) </span>{
                case float64:<span class="cov1" title="1">
                        m.MType = "gauge"
                        *m.Value = val</span>
                case uint64:<span class="cov7" title="3">
                        m.MType = "gauge"
                        *m.Value = float64(val)</span>
                case uint32:<span class="cov1" title="1">
                        m.MType = "gauge"
                        *m.Value = float64(val)</span>
                }
                <span class="cov10" title="5">m.ID = as.collectableMetrics[i]
                as.cache[as.collectableMetrics[i]] = m</span>
        }

        <span class="cov1" title="1">pc, ok := as.cache["PollCount"]
        if ok </span><span class="cov1" title="1">{
                *pc.Delta += 1
                as.cache["PollCount"] = pc
        }</span>

        <span class="cov1" title="1">rv, ok := as.cache["RandomValue"]
        if ok </span><span class="cov1" title="1">{
                *rv.Value = float64(rand.Intn(1000))
                as.cache["RandomValue"] = rv
        }</span>
}

func (as *agentService) UpdateGoPsUtilMetrics() <span class="cov1" title="1">{
        as.mu.Lock()
        defer as.mu.Unlock()

        as.memMetrics, _ = mem.VirtualMemory()
        as.cpuMetrics, _ = cpu.Info()

        totalMemory := float64(as.memMetrics.Total)
        as.cache["TotalMemory"] = models.Metric{ID: "TotalMemory", MType: "gauge", Value: &amp;totalMemory}
        freeMemory := float64(as.memMetrics.Free)
        as.cache["FreeMemory"] = models.Metric{ID: "FreeMemory", MType: "gauge", Value: &amp;freeMemory}

        cpuUtil1 := float64(len(as.cpuMetrics))
        as.cache["CPUutilization1"] = models.Metric{ID: "CPUutilization1", MType: "gauge", Value: &amp;cpuUtil1}
}</span>

func (as *agentService) ReportMetrics(ctx context.Context) error <span class="cov1" title="1">{
        as.mu.RLock()
        defer as.mu.RUnlock()

        return as.client.ReportMetricsJSONBatch(ctx, as.cache)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package metricsservice

import (
        "context"

        "github.com/Chystik/runtime-metrics/internal/models"
        "github.com/Chystik/runtime-metrics/internal/service"
)

type metricsService struct {
        metricsRepo service.MetricsRepository
}

func New(mr service.MetricsRepository) *metricsService <span class="cov10" title="6">{
        return &amp;metricsService{metricsRepo: mr}
}</span>

func (ss *metricsService) UpdateGauge(ctx context.Context, metric models.Metric) error <span class="cov1" title="1">{
        return ss.metricsRepo.UpdateGauge(ctx, metric)
}</span>

func (ss *metricsService) UpdateCounter(ctx context.Context, metric models.Metric) error <span class="cov1" title="1">{
        return ss.metricsRepo.UpdateCounter(ctx, metric)
}</span>

func (ss *metricsService) Get(ctx context.Context, metric models.Metric) (models.Metric, error) <span class="cov4" title="2">{
        return ss.metricsRepo.Get(ctx, metric)
}</span>

func (ss *metricsService) GetAll(ctx context.Context) ([]models.Metric, error) <span class="cov1" title="1">{
        return ss.metricsRepo.GetAll(ctx)
}</span>

func (ss *metricsService) UpdateList(ctx context.Context, metrics []models.Metric) error <span class="cov0" title="0">{
        return ss.metricsRepo.UpdateList(ctx, metrics)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
